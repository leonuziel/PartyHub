# Product Requirements Prompt (PRP) for PartyHub

## Project Overview

PartyHub is a real-time, interactive social gaming platform. The architecture is designed to support a host (on a large screen) and multiple players (on mobile phones) interacting in a shared game room.

---

## **Appendix: Project Context**

### Project Structure

#### Backend (`/Server`)
```
/Server
|
├── src/
│   ├── app.ts
│   ├── core/
│   │   └── SocketManager.ts
│   ├── game/
│   │   ├── BaseGame.ts
│   │   ├── GameFactory.ts
│   │   ├── GameManager.ts
│   │   ├── configurations/
│   │   │   └── quizclash.json
│   │   └── games/
│   │       ├── cardGames/
│   │       │   ├── cards.ts
│   │       │   ├── CardsWarGame.ts
│   │       │   ├── handEvaluator.ts
│   │       │   └── TexasHoldemGame.ts
│   │       ├── ConfigurableGame.ts
│   │       ├── FakeNewsGame.ts
│   │       ├── QuizClashGame.ts
│   │       └── quizclash_questions.json
│   ├── room/
│   │   ├── Room.ts
│   │   └── RoomManager.ts
│   ├── routes/
│   │   ├── debug.ts
│   │   └── gameConfig.ts
│   ├── server.ts
│   ├── types/
│   │   ├── enums.ts
│   │   ├── GameConfiguration.ts
│   │   └── interfaces.ts
│   └── utils/
│       └── codeGenerator.ts
```

#### Frontend (`/client`)
```
/client
|
├── src/
│   ├── App.css
│   ├── App.test.tsx
│   ├── App.tsx
│   ├── components/
│   │   ├── cards/
│   │   ├── card_game_components.txt
│   │   ├── common/
│   │   ├── ComponentRegistry.ts
│   │   ├── controls/
│   │   ├── display/
│   │   ├── gameplay/
│   │   ├── layout/
│   │   ├── missing_components.txt
│   │   ├── player/
│   │   └── reusable_components.txt
│   ├── game/
│   │   ├── CardsWar/
│   │   ├── DynamicViewRenderer.tsx
│   │   ├── FakeNewsGame/
│   │   ├── GameContainer.tsx
│   │   ├── GameView.css
│   │   ├── QuizClash/
│   │   └── TexasHoldem/
│   ├── hooks/
│   │   └── usePlayerRole.ts
│   ├── index.css
│   ├── index.tsx
│   ├── logo.svg
│   ├── pages/
│   │   ├── DebugPage.css
│   │   ├── DebugPage.tsx
│   │   ├── GameCreatorPage.css
│   │   ├── GameCreatorPage.tsx
│   │   ├── GamePage.css
│   │   ├── GamePage.tsx
│   │   ├── GameUITestPage.tsx
│   │   ├── HomePage.css
│   │   ├── HomePage.tsx
│   │   ├── JoinPage.css
│   │   ├── JoinPage.tsx
│   │   ├── LobbyPage.css
│   │   ├── LobbyPage.tsx
│   │   ├── PageLayouts.css
│   │   ├── TestComponentsPage.tsx
│   │   └── wizards/
│   │       ├── GameFlowStage.tsx
│   │       ├── MetadataStage.tsx
│   │       ├── ScreensStage.tsx
│   │       └── StatesStage.tsx
│   ├── react-app-env.d.ts
│   ├── reportWebVitals.ts
│   ├── services/
│   │   └── socketService.ts
│   ├── setupTests.ts
│   ├── store/
│   │   ├── debugStore.ts
│   │   ├── gameStore.ts
│   │   ├── playerHandStore.ts
│   │   ├── playerStore.ts
│   │   └── roomStore.ts
│   └── types/
│       └── types.ts
```

#### Docs (`/Docs`)
```
/Docs
|
├── adding a game checklist.txt
├── Architecture.txt
├── automatic_game_creation_checklist.txt
├── design_system.txt
├── game ideas.txt
├── Games/
│   └── QuizClash.txt
├── PRD.txt
├── PRPs/
│   └── TexasHoldemPoker.txt
├── Requirements.txt
├── templates/
│   ├── add_game_template.txt
│   └── prp_template.txt
└── UX/
    ├── CardsWar.txt
    ├── fakeNews.txt
    ├── Game design strategy.txt
    ├── mainScreens.txt
    ├── quizClash.txt
    └── ui_ux_update_plan.txt
```

### Design & Architecture Summaries

#### 1. Overall Architecture Summary

The system uses a client-server model with a Node.js/Express/Socket.IO backend and a React/TypeScript frontend. The backend manages game rooms, player state, and real-time communication. The frontend is a single-page application that renders different views for the host and players. State synchronization is achieved through `game:state_update` events broadcast from the server.

#### 2. Backend Design Summary

- **Room Management**: `RoomManager` manages all `Room` instances. A `Room` contains players, state (lobby, in-game, finished), and a `GameManager`.
- **Game Logic**: `GameManager` manages the lifecycle of a game using a `GameFactory`. The factory now implements a **dual-system approach**:
    1. It first checks for a `[gameId].json` file in `/src/game/configurations/`.
    2. If a configuration file is found, it instantiates the generic `ConfigurableGame` engine, which runs the game based on the rules and states defined in the JSON.
    3. If no configuration is found, it falls back to the legacy system, creating a specific hardcoded game instance (e.g., `QuizClashGame`) that extends `BaseGame`.
- **Communication**: The backend uses Socket.IO for real-time communication, managed by `SocketManager`. The primary event is `game:state_update`, which sends the complete game state to all clients. A REST API is also exposed via Express for two purposes:
    - `/debug`: Endpoints for server debugging.
    - `/api/game-configs`: A full CRUD API for creating, reading, updating, and deleting game configuration JSON files.

#### 3. Frontend Design Summary

- **State Management**: Zustand is used for global state, split into multiple stores within the `/store` directory. `gameStore` now holds an `isConfigurable` flag to inform the UI which rendering system to use.
- **Component Structure**: The UI is divided into pages (`/pages`). The `HomePage` now fetches a list of all games (both hardcoded and from the `/api/game-configs` endpoint) to populate the game selection screen.
- **Dynamic Rendering**: The `GamePage` contains a `GameContainer` that acts as a router.
    - If `isConfigurable` is `false`, it renders the specific, hardcoded game view (e.g., `QuizClashHostView`).
    - If `isConfigurable` is `true`, it renders the `DynamicViewRenderer`. This component is a pure renderer; it receives a complete UI definition from the server that can change for each player. The server can now define different UIs for players within the same game state (e.g., showing a "Waiting" message to a player who has answered, while others still see the question). This server-driven conditional logic makes the client simpler and the game's configuration more powerful.
- **Game Creation**: A new `GameCreatorPage` has been added, providing a user interface that communicates with the `/api/game-configs` endpoint to allow users to create and save their own game configuration files.
- **Communication**: `services/socketService.ts` encapsulates all Socket.IO logic. It listens for `game:state_update` events and updates the Zustand stores, including the `isConfigurable` flag based on the incoming data structure. UI components do not interact with the socket directly.

#### 4. Design System Summary

- **Color Palette**: A dual-layer system. The "Platform" layer uses a modern dark theme with deep purples/blues (`#12101F`, `#1C192B`) and a vibrant purple accent (`#8A2BE2`). Each "Game" layer has its own unique, energetic palette.
- **Typography**: The platform uses 'Inter' for clean, modern UI text. Games use more expressive, thematic fonts like 'Bangers' and 'Luckiest Guy'.
- **Spacing**: Uses a base unit of 1rem (16px) for consistent margins, padding, and gaps.
- **Implementation**: All design tokens are defined as CSS Custom Properties in `index.css` for global consistency.

#### 5. Sonic System Summary
- **Platform Sounds**: Subtle, clean, and functional UI sounds (clicks, notifications) to provide feedback without being intrusive.
- **Game Sounds**: Each game has a unique, energetic soundtrack and memorable sound effects (stingers for correct/wrong answers, timers, etc.) to enhance the "party" feel. The platform has a main audio jingle and a universal "achievement unlocked" sound.

#### 6. Voice & Tone Summary
- **Platform Voice**: Clear, concise, and helpful (like a "Concierge"). Used for system messages, settings, and menus.
- **Game Voice**: Witty, energetic, and playful (like a "Host"). Used for in-game instructions, questions, and results to entertain players.

### Frontend Component Summary (`client/src/components/`)

#### Common (`/common`)
- `DebugPanel.tsx`: A panel for displaying debug information.
- `Modal.tsx`: A modal dialog that can be displayed over the main content.
- `Spinner.tsx`: A loading spinner to indicate that content is being loaded.

#### Controls (`/controls`)
- `ActionButton.tsx`: A primary button for main user actions.
- `AnswerGrid.tsx`: A grid of possible answers for a question.
- `Button.tsx`: A standard, reusable button component.
- `GameCard.tsx`: A card used to display a game in a list.
- `TextAreaWithCounter.tsx`: A text area with a character counter.
- `VotingOptions.tsx`: Displays options for voting.

#### Display (`/display`)
- `AnswerResult.tsx`: Displays the result of an answer.
- `AwardDisplay.tsx`: Displays any awards a player has received.
- `GameBranding.tsx`: A component to display the branding of the current game.
- `GameTitle.tsx`: A component for displaying the title of the game.
- `Leaderboard.tsx`: Displays the game's leaderboard.
- `PlayerAvatar.tsx`: Displays a player's avatar.
- `PlayerCard.tsx`: A card displaying a player's information.
- `PlayerInfo.tsx`: A component to display information about a player.
- `PlayerStatusContainer.tsx`: A container for the status of all players.
- `PlayerStatusGrid.tsx`: A grid displaying the status of all players.
- `Podium.tsx`: A component to display the top players at the end of a game.
- `PodiumList.tsx`: A list of players on the podium.
- `QuestionDisplay.tsx`: Displays a question.
- `QuestionHeader.tsx`: The header for a question.
- `RankDisplay.tsx`: Displays a player's rank.
- `RankUpdate.tsx`: Displays an update to a player's rank.
- `ResultsList.tsx`: A list of results.
- `SpecialAwards.tsx`: Displays any special awards.
- `WinnerDisplay.tsx`: Displays the winner of the game.

#### Gameplay (`/gameplay`)
- `CountdownTimer.tsx`: A visual timer that counts down from a specified time.

#### Layout (`/layout`)
- `CenteredMessage.tsx`: A component to display a message centered on the screen.
- `HostFrame.tsx`: A container for the host's view.
- `HostViewContainer.tsx`: A container for the main content of the host's view.
- `PlayArea.tsx`: The main area where the game is played.
- `PlayerViewContainer.tsx`: A container for the player's view.

#### Card Game Components (`client/src/components/cards/`)
- `BiddingPopup.tsx`: A popup for bidding.
- `Card.tsx`: A single card component.
- `CardFan.tsx`: A fan of cards.
- `CardSlot.tsx`: A slot for a card.
- `Deck.tsx`: A deck of cards.
- `DiscardPile.tsx`: A pile of discarded cards.
- `Hand.tsx`: A player's hand of cards.
- `LastPlayedCard.tsx`: The last card that was played.
- `Meld.tsx`: A meld of cards.
- `PlayerHandDisplay.tsx`: Displays a player's hand.
- `Scoreboard.tsx`: A scoreboard for a card game.
- `Trick.tsx`: A trick of cards.
- `TrumpIndicator.tsx`: Indicates the trump suit.

### Available Games (`client/src/game/`)

- **CardsWar**: A simple card game where players compare cards, and the higher card wins. Ties result in a "war". Contains views for both host and player.
- **FakeNewsGame**: A trivia game where players submit fake answers to a question, and then vote on what they believe is the real answer. Contains views for writing, voting, and revealing answers for both host and player.
- **QuizClash**: A multiple-choice trivia game where players answer questions as quickly as possible. Contains views for asking questions and revealing answers for both host and player.
- **TexasHoldem**: A poker game where players are dealt two private cards and share five community cards, betting on the strength of their hand.
- **(Dynamically Created Games)**: The new system allows for an unlimited number of games to be created via JSON configuration. These games are powered by the `ConfigurableGame` engine and the `DynamicViewRenderer` on the frontend.
